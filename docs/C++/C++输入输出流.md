---
typora-root-url: Image
---

# C++输入和输出流

程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。

C++输入输出包含以下三个方面的内容：

* 对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，**简称标准I/O。**
* 以外存磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，**简称文件I/O。**
*  对内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间(实际上可以利用该空间存储任何信息)。这种输入和输出称为字符串输入输出，**简称串I/O。**

C++编译系统提供了用于输入输出的`iostream`类库。`iostream`这个单词是由3个部 分组成的，即i-o-stream，意为输入输出流。在`iostream`类库中包含许多用于输入输出的 类

## 1、I/O类库中的常见流类

| 类名       | 作用                                 | 头文件    |
| ---------- | ------------------------------------ | --------- |
| ios        | 抽象基类                             | iostream  |
| istream    | 通用输入流和其他输入流的基类         | iostream  |
| ostream    | 通用输出流和其他输出流的基类         | iostream  |
| iostream   | 通用输入输出流和其他输入输出流的基类 | iostream  |
| ifstream   | 输入文件流类                         | fstream   |
| ofstream   | 输出文件流类                         | fstream   |
| fstream    | 输入输出文件流类                     | fstream   |
| istrstream | 输入字符串流类                       | strstream |
| ostrstream | 输出字符串流类                       | strstream |
| strstream  | 输入输出字符串流类                   | strstream |

`ios`是抽象基类，由它派生出`istream`类和`ostream`类，两个类名中第1个字母i和o分别代表输入`input`和输出`output`。` istream`类支持输入操作，`ostream`类支持输出操作， `iostream`类支持输入输出操作。`iostream`类是从`istream`类和`ostream`类通过多重继承而派生的类。其继承层次见上图表示。

C++对文件的输入输出需要用`ifstrcam`和`ofstream`类，两个类名中第1个字母i和o分别代表输入和输出，第2个字母f代表文件 (file)。`ifstream`支持对文件的输入操作，` ofstream`支持对文件的输出操作。类`ifstream`继承了类`istream`，类`ofstream`继承了类`ostream`，类`fstream`继承了 类`iostream`。见图 

![C++类库中的流类](/C++类库中的流类.png)

> 其中，图中的箭头代表各个类之间的派生关系。比如，`ios `是所有流类的基类，它派生出 `istream` 和 `ostream`。特别需要指出的是，为了避免多继承的二义性，从 `ios` 派生出 `istream` 和` ostream` 时，均使用了 `virtual `关键字（虚继承）。

图 中这些流类各自的功能分别为：

* `istream`：常用于接收从键盘输入的数据；
* `ostream`：常用于将数据输出到屏幕上；
* `ifstream`：用于读取文件中的数据；
* `ofstream`：用于向文件中写入数据；
* `iostream`：继承自 `istream `和 `ostream `类，因为该类的功能兼两者于一身，既能用于输入，也能用于输出；
* `fstream`：兼 `ifstream` 和 `ofstream `类功能于一身，既能读取文件中的数据，又能向文件中写入数据。

## 2、与iostream类库有关的头文件

`iostream`类库中不同的类的声明被放在不同的头文件中，用户在自己的程序中用#include命令包含了有关的头文件就相当于在本程序中声明了所需 要用到的类。可以换 —种说法：头文件是程序与类库的接口，`iostream`类库的接口分别由不同的头文件来实现。常用的有 :

* `iostream`  包含了对输入输出流进行操作所需的基本信息。
* `fstream ` 用于用户管理的文件的I/O操作。
* `strstream ` 用于字符串流I/O。
* `stdiostream`  用于混合使用C和C + +的I/O机制时，例如想将C程序转变为C++程序。
* `iomanip ` 在使用格式化I/O时应包含此头文件。

## 3、在iostream头文件中定义的流对象

在 `iostream` 头文件中定义的类有` ios`，`istream`，`ostream`，`iostream`，等。

在`iostream`头文件中不仅定义了有关的类，还定义了4种流对象，

| 对象 | 含义       | 对应设备 | 对应的类           | c语言中相应的标准文件 |
| ---- | ---------- | -------- | ------------------ | --------------------- |
| cin  | 标准输入流 | 键盘     | istream_withassign | stdin                 |
| cout | 标准输出流 | 屏幕     | ostream_withassign | stdout                |
| cerr | 标准错误流 | 屏幕     | ostream_withassign | stderr                |
| clog | 标准错误流 | 屏幕     | ostream_withassign | stderr                |

## 4、在iostream头文件中重载运算符

“<<”和“>>”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在`iostream`头文件中对它们进行了重载， 使它们能用作标准类型数据的输入和输出运算符。所以，在用它们的程序中必须用#include命令把`iostream`包含到程序中。

* `#include <iostream>`
* `>>a`表示将数据放入a对象中。
* `<<a` 表示将a对象中存储的数据拿出。

# 标准I/O流

标准I/O对象:`cin` `cout`，`cerr`，`clog`

## 1、cout流对象

`cout`是console output的缩写，意为在控制台（终端显示器）的输出。强调几点：

* ​	`cout`不是C++预定义的关键字，它是`ostream`流类的对象，在`iostream`中定义。 顾名思义，流是流动的数据，`cout`流是流向显示器的数据。`cout`流中的数据是用流插入运算符“<<”顺序加入的。如果有:
    `cout<<"I "<<"study C++ "<<"very hard. << “hello world !";`

  按顺序将字符串"I ", "study C++ ", "very hard."插人到`cout`流中，`cout`就将它们送	到显示器，在显示器上输出字符串"I study C++ very hard."。`cout`流是容纳数据的载	体，它并不是一个运算符。人们关心的是`cout`流中的内容，也就是向显示器输出什么。

* 用`cout<<`输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数	据的类型，并根据其类型选择调用与之匹配的运算符重 载函数。这个过程都是自动的，	用户不必干预。如果在C语言中用`prinf`函数输出不同类型的数据，必须分别指定相应	的输出格式符，十分麻烦，而且容易出错。C++的I/O机制对用户来说，显然是方便	而安全的。

* `cout`流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向`cout`流插人一个`endl`时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符， 并刷新流（清空缓冲区）。注意如果插人一个换行符”\n“如`cout<<a<<"\n"`，则只输出和换行，而不刷新`cout` 流(但并不是所有编译系统都体现出这一区别）。

* 在`iostream`中只对"<<"和">>"运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用"<<"和">>"运算符对其进行输入输出，按照重运算符重载来做。

## 2、cerr流对象

`cerr`流对象是标准错误流，`cerr`流已被指定为与显示器关联。`cerr`的 作用是向标准错误设备(standard error device)输出有关出错信息。`cerr`与标准输出流`cout`的作用和用法差不多。但有一点不同：`cout`流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而`cerr`流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时 应该用`cerr`。`cerr`流中的信息是用户根据需要指定的。

## 3、clog流对象

`clog`流对象也是标准错误流，它是console log的缩写。它的作用和`cerr`相同，都是在终端显示器上显示出错信息。区别：`cerr`是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇`endl`时向显示器输出。

## 4、缓冲区

缓冲区(Buffer)就是在内存中预留指定大小的存储空间用来对输入/输出(I/O)的数据作临时存储，这部分预留的内存空间就叫做缓冲区

缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区

1. 为什么要引入缓冲区

   * 比如我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。
   * 我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。

2. 作用：缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。

3. 缓冲区的类型：缓冲区 分为三种类型：全缓冲、行缓冲和不带缓冲。

   * 全缓冲：当填满标准I/O缓存后才进行实际I/O操作。全缓冲的典型代表是对磁盘文件的读写。
   * 行缓冲：当在输入和输出中遇到换行符时，执行真正的I/O操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的I/O操作。典型代表是键盘输入数据。
   * 无缓冲：不进行缓冲，标准出错情况`stderr`是典型代表，这使得出错信息可以直接尽快地显示出来。

4. 缓冲区的刷新：下列情况会引发缓冲区的刷新:

   * 缓冲区满时；
   * 执行flush语句；
   * 执行`endl`语句；
   * 关闭文件。

   可见，缓冲区满或关闭文件时都会刷新缓冲区，进行真正的I/O操作。另外，在C++中，我们可以使用flush函数来刷新缓冲区（执行I/O操作并清空缓冲区），如：

   ```c++
   cout<<flush; //将显存的内容立即输出到显示器上进行显示  
   cout<<”\n” <<flush; 
   ```

# 标准输入流

标准输入流对象cin，重点掌握的函数：

## 1、`cin.get()`             一次只能读取一个字符

```c++
//链式编程
void test(){
	char ch1,ch2,ch3,ch4;
	cin.get(ch1).get(ch2).get(ch3).get(ch4);   //输入：123456  缓冲区：123456
	cout<<ch1<<ch2<<ch3<<ch4<<endl;     //输出：1234   //缓冲区：56
}

void test01(){
    //输入  a  s     第一次 a  第二次  s  第三次 换行  第四次 等待下次输入
	char c = cin.get();   //输入：as  缓冲区：as+\n
	cout << "c = " << c << endl;  //输出：c=a    缓冲区：s+\n
	c = cin.get();       //从缓冲区取一个字符给c
	cout << "c = " << c << endl;   //输出：c=s   缓冲区：\n
	c = cin.get();       //从缓冲区取一个字符给c
	cout << "c = " << c << endl;   //缓冲区：空
	c = cin.get();       //从键盘读取一个字符
	cout << "c = " << c << endl;
}
```

## 2、`cin.get(一个参数)`           读一个字符

```c++
void test(){
	char ch=cin.get();    //键盘输入：123----在缓冲区：123
	cout<<ch<<endl;       //输出：1---从缓冲区取走一个字符  缓冲区：23
	cin.get(ch);          //从缓冲区取走一个字符给赋给ch  缓冲区：3
	cout<<ch<<endl;       //输出：2
}
```

## 3、`cin.get(两个参数) `              可以读字符串

利用`cin.get`获取字符串时候，换行符遗留在缓冲区中

```c++
void test(){
	char buf[1024] = { 0 };
	cin.get(buf, 1024);

	char c = cin.get();
	//利用cin.get获取字符串时候，换行符遗留在缓冲区中
	if (  c== '\n'){
		cout << "换行符遗留在缓冲区" << endl;     
	}
	else{
		cout << "换行符不在缓冲区" << endl;
	}
	cout << buf << endl;
}
```

## 4、`cin.getline() `        获取字符串

利用`cin.getline`获取字符串时候，换行符不会被取走，也不在缓冲区中，而是直接扔掉

```c++
void test(){
	char buf[1024] = { 0 };
	//利用cin.getline获取字符串时候，换行符不会被取走，也不在缓冲区中，而是直接扔掉
	cin.getline(buf, 1024);
	char c = cin.get();
	if (c == '\n'){
		cout << "换行符遗留在缓冲区" << endl;
	}
	else{
		cout << "换行符不在缓冲区" << endl;
	}
	cout << buf << endl;
}

```

## 5、`cin.ignore()`      忽略 默认忽略1个字符， 如果填入参数X，代表忽略X个字符

```c++
void test(){
    cin.ignore(2);       //忽略2个字符   输入：123456   缓冲区：3456---两个字符被忽略
	char c = cin.get();  //从缓冲区取走一个字符给c       缓冲区：456    
	cout << "c = " << c << endl;        //输出：c=3----两个字符被忽略
}
```

## 6、`cin.peek() `         偷窥 

```c++
void test(){
    char c = cin.peek();          //输入：12 窥探一个字符：1    缓冲区：12+\n
	cout << "c = " << c << endl;      //输出：c=1  

	c = cin.get();         //从缓冲区取走一个字符给c       缓冲区：2+\n
	cout << "c = " << c << endl;      //输出：c=1

	c = cin.get();         //从缓冲区取走一个字符给c       缓冲区：\n
	cout << "c = " << c << endl;      //输出：c=2
}
```

## 7、`cin.putback()`      放回 放回原位置

```c++
void test(){
    char c = cin.get();       //输入：123456 缓冲区：123456 获取一个字符给c
	cin.putback(c);          //将c放回原位置

	char buf[1024] = { 0 };

	cin.getline(buf, 1024);   //从缓冲区获取一个字符串
	cout << buf << endl;      //输出：123456
}
```

## 8、案例一

判断用户输入的是数组还是字符串

```c++
void test(){
    cout << "请输入一个字符串或者数字" << endl;
	char ch=cin.peek();
	if(ch>'0'&&ch<='9'){
		int num;
		cin>>num;
		cout<<"用户输入的是数字"<<endl;
	}
	else{
		char buf[1024]={0};
		cin>>buf;
		cout<<"用户输入的是字符串"<<endl;
	}	
}
```

## 9、案例二

用户输入 0 ~ 10 之间的数字，如果输入有误，重新输入

```c++
void test(){
	cout << "请输入 0 ~ 10 之间的数字" << endl;
	int num;
	while (true){
		cin >> num;
		if (num >= 0 && num <= 10){
			cout << "输入正确，输入值为：" << num << endl;
			break;
		}
		//清空缓冲区 重置标志位 
		cin.clear();
		cin.sync();
		//cin.ignore();//vs2013以上版本加入 
		//如果标志位为 0  代表缓冲区正常    如果标志位为1   缓冲区异常
		cout << " cin.fail()  = " << cin.fail() << endl;	
		cout << "输入有误，请重新输入： " << endl;
	}	
}
```

# 标准输出流

## 1、字符输出

* `cout.flush()`            刷新缓冲区 Linux下有效

  ```c++
  void test(){	
  	cout << "hello world";
  	//刷新缓冲区
  	cout.flush(); 
  }
  
  ```

* `cout.put() `                向缓冲区写字符

  ```c++
  void test(){
  	cout.put('a');
  	//链式编程
  	cout.put('h').put('e').put('l').put('l').put('o');
  }
  ```

* `cout.write()`             从`buffer`中写`num`个字节到当前输出流中

  ```c++
  void test(){
  	char* str = "hello world!";
  	cout.write(str, strlen(str));
  }
  
  void test01(){
  	char* str = "*************";
  	for (int i = 1; i <= strlen(str); i ++){
  		cout.write(str, i);
  		cout << endl;
  	}
  }
  
  void test02(){
  	char* str = "*************";
  	for (int i = strlen(str); i > 0; i --){
  		cout.write(str, i);
  		cout << endl;
  	}
  }
  ```

## 2、格式化输出

在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式输出一个整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。

`#include <iomanip> `              控制符格式化输出  头文件

1. 使用控制符的方法

   | 控制符                       | 作用                                                         |
   | ---------------------------- | ------------------------------------------------------------ |
   | dec                          | 设置整数的基数为10                                           |
   | hex                          | 设置整数的基数为16                                           |
   | oct                          | 设置 整数的基数为8                                           |
   | setbase(n)                   | 设置整数的基数为n(n只能是16，10，8之一)                      |
   | setfill(c)                   | 设置填充字符c，c可以是字符常量或字符变量                     |
   | setprecision(n)              | 设置实数的精度为n位。在以一般十进制小数形式输出时，n代表有效数字。在以fixed(固定小数位 数)形式和scientific(指数)形式输出时，n为小数位数。 |
   | setw(n)                      | 设置字段宽度为n位。                                          |
   | setiosflags(ios::fixed)      | 设置浮点数以固定的小数位数显示。                             |
   | setiosflags(ios::scientific) | 设置浮点数以科学计数法(即指数形式)显示。                     |
   | setiosflags(ios::left)       | 输出数据左对齐。                                             |
   | setiosflags(ios::right)      | 输出数据右对齐。                                             |
   | setiosflags(ios::shipws)     | 忽略前导的空格。                                             |
   | setiosflags(ios::uppercase)  | 在以科学计数法输出E和十六进制输出字母X时，以大写表示。       |
   | setiosflags(ios::showpos)    | 输出正数时，给出“+”号。                                      |
   | resetiosflags                | 终止已设置的输出格式状态，在括号中应指定内容。               |

   ```c++
   void test()
   {
   	int number = 99;
   	cout << setw(20)     //设置宽度
   		<< setfill('*')  //设置填充
   		<< setiosflags(ios::showbase)  //显示基数
   		<< setiosflags(ios::left)  //设置左对齐
   		<< hex   //显示十六进制
   		<< number
   		<< endl;
   }
   ```

2. 使用流对象的有关成员函数。

   通过调用流对象`cout`中用于控制输出格式的成员函数来控制输出格式。用于控制输出格式的常用的成员函数如下：

   | 流成员函数   | 与之作用相同的控制符 | 作用                                                         |
   | ------------ | -------------------- | ------------------------------------------------------------ |
   | precision(n) | setprecision(n)      | 设置实 数的精度为n位。                                       |
   | width(n)     | setw(n)              | 设置字段宽度为n位。                                          |
   | fill(c)      | setfill(c)           | 设置填充字符c。                                              |
   | setf( )      | setiosflags( )       | 设置输出格式状态，括号中应给出格式状态，内容与控制符setiosflags括号中内容相同。 |
   | ubsetf( )    | resetiosflags( )     | 终止已设置的输出格式状态。                                   |

   流成员函数`setf`和控制符`setiosflags`括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类`ios`中被定义为枚举值。因此在引用这些格式标志时要在前面加上类名`ios`和域运算符“::”。格式标志见表：

   | 格式标志        | 作用                                                       |
   | --------------- | ---------------------------------------------------------- |
   | ios::left       | 输出数据在本域宽范 围内左对齐                              |
   | ios::right      | 输出数据在本域宽范围内右对齐                               |
   | ios::internal   | 数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充 |
   | ios::dec        | 设置整数的基数为10                                         |
   | ios::oct        | 设置整数的基数为8                                          |
   | ios::hex        | 设置整数的基数为16                                         |
   | ios::showbase   | 强制输出整数的基数(八进制以0打头，十六进制以0x打头)        |
   | ios::showpoint  | 强制输出浮点数的小点和尾数0                                |
   | ios::uppercase  | 在以科学计数法输出E和十六进制输出字母X时，以大写表示       |
   | ios::showpos    | 输出正数时，给出“+”号。                                    |
   | ios::scientific | 设置浮点数以科学计数法(即指数形式)显示                     |
   | ios::fixed      | 设置浮点数以固定的小数位数显示                             |
   | ios::unitbuf    | 每次输出后刷新所有流                                       |
   | ios::stdio      | 每次输出后清除 stdout，stderr                              |

   ```c++
   void test(){
   	int number = 99;
   	cout.width(20); //指定宽度为20
   	cout.fill('*'); //填充
   	cout.setf(ios::left);  //左对齐
   	cout.unsetf(ios::dec); //卸载十进制
   	cout.setf(ios::hex);  //安装十六进制
   	cout.setf(ios::showbase);  //显示基数
   	cout.unsetf(ios::hex);  //卸载十六进制
   	cout.setf(ios::oct);   //安装八进制
   	cout << number << endl;
   }
   ```

## 3、注意事项

1. 成员函数width(n)和控制符`setw(n)`只对其后的第一个输出项有效。如：

   ```c++
   cout. width(6);
   cout <<20 <<3.14<<endl;
   //输出结果为:****203.14
   ```

   在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出）。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)， 而必须在输出每一项前都调用一次width(n)

2. 格式标志表中的输出格式状态分为5组，每一组中同时只能选用一种（例如`dec`、`hex`和`oct`中只能选一，它们是互相排斥的）。在用成员函数`setf`和 控制符`setiosflags`设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数`unsetf`（对应于成员函数self）或 `resetiosflags`（对应于控制符`setiosflags`），先终止原来设置的状态。然后再设置其他状态，大家可以从本程序中看到这点。程序在开 始虽然没有用成员函数self和控制符`setiosflags`设置用`dec`输出格式状态，但系统默认指定为`dec`，因此要改变为`hex`或`oct`，也应当先 用`unsetf` 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数`setf`设置了`hex`和`oct`格式，由于未终止`dec`格式，因 此`hex`和`oct`的设置均不起作用，系统依然以十进制形式输出。

   同理，程序的`unsetf `函数的调用也是不可缺少的。

3.  用`setf `函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在`ios`类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：

     `cout.setf(ios::internal | ios::showpos); ` //包含两个状态标志，用"|"组合

















