# 内联函数引出宏缺陷

在c中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用时入栈、出栈的开销

## 1、宏必须要加括号才能保证运算的准确性

```c++
#define add(x,y) x+y
#define add1(x,y) ((x)+(y))

int add2(int x,int y)
{
    return x+y;
}
void test()
{
    int x=10;
    int y=5;
    //1、宏函数
    cout<<add(x,y)<<endl;        //结果：15
    cout<<add(x,y)*10<<endl;     //结果：60   预期结果：（10+5）*10=150
    cout<<add1(x,y)*10<<endl;    //结果：150
    //2、普通函数
    cout<<add2(x,y)*10<<endl;    //结果：150
}
```

## 2、即使加了括号也无法避免一些错误

```c++
#define compare(a,b) (((a)>(b))?(a):(b))

int compare1(int a,int b)
{
    return a>b?a:b;
}

void test()
{
    int a=10;
    int b=5;
    //1、宏函数
    cout<<compare(a,b)<<endl;      //结果：10
    cout<<compare(++a,b)<<endl;    //结果：12
    cout<<compare(a++,b)<<endl;    //结果：13
    cout<<"a="<<a<<endl;           //结果：14
    //2、普通函数
    int m=10;
    int n=5;
    cout<<compare1(m,n)<<endl;      //结果：10
    cout<<compare1(++m,n)<<endl;    //结果：11
    cout<<compare1(m++,n)<<endl;    //结果：11
    cout<<"m="<<m<<endl;            //结果：12
}
```

## 3、预定义宏函数没有作用域概念，无法作为一个类的成员函数

也就是说预定义宏没有办法表示类的范围

# 内联函数

* 内联函数本身也是一个真正的函数
* 内联函数具有普通函数的所有行为
* 唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销

## 1、内联函数定义方法

在普通函数前面加关键字`inline`使之成为内联函数，但必须注意函数申明和实现中都加关键字`inline`才行

```c++
//申明内联函数
inline int add(int a,int b);

//内联函数实现
inline int add(int a,int b)
{
    return a+b;
}
```

内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的**压栈**，**跳转**，**返回**的开销。我们可以理解为内联函数是以**空间换时间**。

## 2、类内部的内联函数

为了定义内联函数，通常必须在函数定义前面放一个`inline`关键字。但是在类内部定义内联函数时并不是必须的。任何在类内部定义的函数自动成为内联函数。

```c++
class Student
{
    int m_Age;   //年龄
    
    void Set_Age(int age)   //自动转换为内联函数
    {
        m_Age=age;
    }
}
```

## 3、以下情况编译器可能考虑不会将函数进行内联编译

1. 存在任何形式的循环语句
2. 存在过多的条件判断语句
3. 函数体过于庞大
4. 对函数进行取址操作  

内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。

## 4、编译器对函数的处理

1. 对于任何类型的函数，编译器会将函数类型(包括函数名字，参数类型，返回值类型)放入到符号表中。同样，当编译器看到内联函数，并对内联函数体进行分析没有发现错误时，也会将内联函数放入符号表。
2. 当调用一个内联函数的时候，编译器首先确保传入参数类型是正确匹配的，或者如果类型不完全匹配，但是可以将其转换为正确类型，并且返回值在目标表达式里匹配正确类型，或者可以转换为目标类型，内联函数就会直接替换函数调用，这就消除了函数调用的开销。
3. 假如内联函数是成员函数，对象this指针也会被放入合适位置。
4. 类型检查和类型转换、包括在合适位置放入对象this指针这些都是预处理器（宏）不能完成的。

