# 库的介绍

## 1、什么是库

库是二进制文件，是源代码文件的另一种表现形式，是加了密的源代码；是一些功能相近或是相似的函数体的集合。

## 2、使用库的好处

* 提高代码的可重用性，而且还可以提高程序的健壮性；
* 可减少开发者的代码质量，缩短开发周期。

## 3、库制作完成后，如何给用户使用

* 头文件---包含了库函数的申明
* 库文件---包含了库函数的代码实现
* 注意：库不能单独使用，只能作为其他执行程序的一部分完成某些功能，也就是说只能被其他程序调用才能使用

# 静态库（staitc library）

静态库可以认为是一些目标代码的集合，是在可执行程序运行前已经加入到执行代码中，成为执行程序的一部分。按照习惯，一般以 .a 做文件后缀名

静态库的命名一般分为三个部分：

* 前缀：lib
* 库名：自定义即可，如test
* 后缀：.a

所以最终的静态库的名字应该为：libtest.a

## 1、静态库的制作

下面以fun1.c , fun2.c和head.h三个文件为例讲述静态库的制作和使用, 其中head.h文件中有函数的声明,  fun1.c和fun2.c中有函数的实现.

* 步骤1：将c源文件生成对应的.o文件

  `gcc -c fun1.c fun2.c`

  或者分别生成.o文件：

  `gcc -c fun1.c -o fun1.o`

  `gcc -c fun2.c -o fun2.o`

* 步骤2：使用打包工具ar将准备好的.o文件打包为.a文件

  在使用ar工具时需要添加参数rcs（r--更新、c--创建、s：建立索引）

  命令：ar rcs 静态库名 .o文件

  `ar rcs libtest.a fun1.o fun1.o`

## 2、静态库的使用

静态库制作完成之后，需要将.a文件和头文件一起发布给用户

假设测试文件为mian.c，静态库文件为libtest.a，头文件为head.h

用到的参数：

* -L：指定要连接的库所在目录

* -l（小写L）：指定链接时需要的静态库，去掉前缀和后缀

* -I（大写i）：指定mian.c文件用到的头文件head.h所在的路劲

  `gcc -o mian1 main.c -L./ -ltest -I./`

# 静态库的优缺点

## 1、优点

* 库函数最终被打包到应用程序中，实现是函数本地化，寻址方便、速速度快。

  （库函数调用效率==自定义函数使用效率）

* 程序在运行时域函数库在无瓜葛，移植方便。

## 2、缺点

* 消耗系统资源较大，每个进程使用静态库时都要复制一份，无端浪费内存。
* 静态库会给程序的更新、部署和发布带来麻烦。如果静态库libxxx.a更新了，所有使用它的应用程序都需要重新编译、发布给用户（对于玩家来说很小的改动，却导致整个程序重新下载）。

# 共享库（shared library）动态库

共享库是在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份共享库的拷贝，规避了空间的浪费问题。

动态库在程序运行时才被载入，也解决了静态看对程序的更新、部署和发布带来的的麻烦，用户只需更新动态库即可，增加更新。按照习惯一般以 .so 做文件的后缀名，共享库的命名一般分为三个部分：

* 前缀：lib
* 库名称：自定义即可，如test
* 后缀：.so

所以最终的动态库的名字应该为：libtest.so

## 1、动态库的制作

1. 生成目标文件.o，此时要加编译选项：-fPIC（fpic）

   `gcc -fpic -c fun1.c fun2.c`

   参数：-fpic创建于与地址无关的编译程序，目的就是为了能够在多个应用程序间共享

2. 生成共享库，此时要加链接器选项：-shared（指定生成动态链接库）

   `gcc -shared fun1.o fun2.o -o libtest.so`

## 2、动态库的使用

* -L：指定要连接的库所在目录

* -l：指定链接时需要的动态库，去掉前缀和后缀

* -I：指定main.c文件用到的头文件head.h所在的路径

  然后运行：./main，发现报错

分析为什么会在执行的时候找不到libtest.so库

* 当系统加载可执行代码时候, 能够知道其所依赖的库的名字, 但是还需要知道所依赖的库的绝对路径。此时就需要系统动态载入器(dynamic linker/loader)。

  ldd命令可以查看可执行文件依赖的库文件, 执行lddmain,可以发现libtest.so找不到.

* 对于elf格式的可执行程序，是由ld-linux.so\*来完成的, 它先后搜索elf文件的 DT_RPATH段 — 环境变量LD_LIBRARY_PATH — /etc/ld.so.cache文件列表 — /lib/, /usr/lib目录找到库文件后将其载入内存。

  使用file命令可以查看文件的类型: file main

如何让系统找到共享库

* 拷贝自己制作的共享库到 /lib 或者 /usr/lib

* 临时设置 LD_LIBRARY_PATH：

  `export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径`

* 永久设置，把`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径`，设置到 ~。、bashrc 文件中，然后执行下列三种办法之一：

  执行 . ~/bashrc 使配置文件生效（第一个. 后面有一个空格）

  执行source~/.bashrc配置文件生效

  退出当前终端，然后再次登录也可以使配置文件生效

* 永久设置，把`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:库路径`，设置到/etc/profile文件中

* 将其添加到 /etc/ld.so.conf文件

  编辑/etc/ld.so.conf 文件，加入库文件所在目录的路径

  运行sudo ldconfig -v，该命令会重建/etc/ld.so.cache文件


## 3、共享库的特点

* 动态库把对一些库函数的 链接载入推迟到程序运行的时期
* 可以实现进程之间的资源共享。（因为动态库也称为共享库）
* 将一些程序升级变得简单
* 甚至可以真正做到链接载入完全由程序员在程序代码中控制（显示调用）

# 比较静态库和动态库的优缺点

## 1、静态库的优点

* 执行速度快，是因为静态库已经编译到可执行文件的内部了
* 移植方便，不依赖其他的库文件

## 2、静态库的缺点

* 耗费内存，是由于每一个静态库的可执行程序都会加载一次
* 部署更新麻烦，因为静态库修改后所有的调用到这个静态库的可执行文件都需要重新编译

## 3、动态库的优点

* 节省内存
* 部署升级方便，只需要替换动态库即可，然后再重启服务

## 4、动态库的缺点

* 加载速度比静态库慢
* 移植性差，需要把所有用到的动态库都移植

注意：由于静态库生成的可执行文件是把静态库加载到了其内部，所以静态库生成的可执行文件一般会比动态库大



