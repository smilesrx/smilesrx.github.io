# 1、树---非线性数据结构。

树（Tree）是 n （n>=0) 个节点的有限集，他或为空树（n=0）；或为非空树，对于非空树T：

(1) 有且仅有一个称之为根的节点；

(2) 除根节点以外的其余节点可分为 m（m>0）个互不相交的有限集，其中每一个集合本身又是一棵树，并且成为根的子树（SubTree)。

数的基本术语：

(1) 结点：树中的每一个独立的单位。包含一个数据元素及若干指向其子树的分支

(2) 结点的度：结点拥有的子树的个数称为结点的度

(3) 树的度：树的度是树内各结点度的最大值

(4) 叶子：度为0的结点称为叶子或终端结点

(5) 非终端结点：度不为0的结点称为非终端结点或分支结点

(6) 双亲和孩子：结点的子树的根称之为该结点的孩子。该结点称之为孩子的双亲

(7) 兄弟：同一双亲的孩子之间互称兄弟

(8) 祖先：从根结点到该结点所经过分支上的所有结点

(9) 子孙：以某结点为根的子树中的任一结点都称为该结点的子孙

(10) 层次：结点的层次从根开始定义，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点层次加1

(11) 堂兄弟：双亲在同一层的结点互为堂兄弟

(12) 树的深度：树的结点的最大层次称为树的深度或高度

(13) 有序树：n 结点各子树从左至右有序，不能互换（左为第一）

(14) 无序树：结点各子树可互换位置。

(15) 森林：m（m>=0）棵互不相交的数的集合

# 2、二叉树

二叉树（Binary Tree）是n（n>=0）个结点所构成的集合，它或为空树（n=0）；或为非空树，对于非空树T：

(1) 有且仅有一个称之为根的结点；

(2) 除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为左子树和右子树，且T1和T2本身又都是二叉树

## <1> 二叉树和树的区别

(1) 二叉树没个结点至多只有两棵子树（即二叉树中没有结点的度大于2的结点）

(2) 二叉树的子树有左右之分，其次序不能任意颠倒。

## <2> 二叉树的性质

(1) 在二叉树的第i层上至多有2 的i-1次方个结点（i>0）

(2) 深度为k的二叉树至多有2的k次方-1个结点（k>0）

(3) 对于任何一棵二叉树，若度为2的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1）

(4) 满二叉树：一棵深度为k 且有2的k次方 -1个结点的二叉树。

​	特点：每一层上的结点数都是最大结点数，即每一层i上结点数都具有最大值2的i-1次方

(5) 完全二叉树：除最后一层外，每一层上的[节点](http://baike.baidu.com/view/47398.htm)数均达到最大值；在最后一层上只缺少右边的若干结点

​	特点：叶子结点只可能在层次最大的两层上出现；

​				对任一结点，若其右分支下的子孙的最大层次为 L，则其左分支的子孙最大层次为L或L+1.

(6) n 具有n个结点的完全二叉树的深度必为Log2(n)向取整+1

(7)对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）

# 3、二叉树的存储结构

二叉树的存储结构也可以采用顺序存储和链式存储

## <1> 顺序存储结构

```c
#define MAXSIZE 100    //二叉树的最大结点数
typedef TElemType SqBiTree[MAXSIZE];    //0号单元存储根结点
SqBiTree bt;
```

顺序存储结构仅适用于完全二叉树

## <2> 链式存储结构

二叉树的链表中结点至少包含3个域：数据域和左、右指针域

```c
typedef struct BiTree
{
    TElemType data;    //结点数据域
    struct BiTNode *lchild,*rchild;    //左右孩子指针
}BiTNode，*BiTree;
```

# 4、遍历二叉树

遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列

先（跟）序遍历、中（跟）序遍历、后（跟）序遍历

```c
//中序遍历二叉树的递归算法
void InOrderTraverse(BiTree T)
{
    //中序遍历二叉树T的递归算法
    if(T)   //若二叉树非空
    {
        InOrderTraverse(T->lchild);    //中序遍历左子树
        cout<<T->data;                 //访问根结点
        InOrderTraverse(T->rchild);    //中序遍历右子树
    }
}
```

```c
//中序遍历的非递归算法
void InOrderTraverse(BiTree T)
{
    //中序遍历二叉树T的非递归算法
    Init_Stack(S);
    BiTree *p,*q;
    p=T;
    q=new BiTNode;
    while(p||!StackEmpty(S))
    {
        if(p)         //p非空
        {
            Push_Stack(S,p);   //跟指针进栈
            p=p->lchild;       //跟指针近=进栈，遍历左子树
        }
        else         //p为空
        {
            Pop_Stack(S,q);     //退栈
            cout<<q->data;      //访问根结点
            p=q->rchild;        //遍历右子树
        }
    }
}
```

根据遍历序列确定二叉树

(1) 由二叉树的**先序序列和中序序列**能唯一的确定一棵二叉树

​	在先序序列中 ，第一个结点一定是二叉树的根结点，另：跟结点在中序序列中必然将中序序列分割成两个子序列（左子树序列、右子树序列

(2) 由其后**序序列和中序序列**能唯一的确定一棵二叉树

​	在后序序列中 ，最后一个结点一定是二叉树的根结点，另：跟结点在中序序列中必然将中序序列分割成两个子序列（左子树序列、右子树序列

# 5、二叉树遍历算法的应用

## <1> 创建二叉树的存储结构-----二叉链表

```c
void Create_BiTree(BiTree &T)
{
    //按先序次序输入二叉树中的结点值（一个字符），创建二叉链表表示的二叉树T
    cin>>ch;
    if(ch=='#')
    {
        T=NULL;    //递归结束，建空树
    }
    else
    {
        T=new BiTNode;    //生成跟结点
        T->data=ch;     //根结点数据域置为ch
        Create_BiTree(BiTree T->lchild);      //递归创建左子树
        Create_BiTree(BiTree T->rchild);      //递归创建右子树
    }
}
```

## <2> 复制二叉树

```c
void Copy_BiTree(BiTree &T,BiTree &NewT)
{
    //复制一棵和T完全相同的二叉树
    if(T==NULL)
    {
        NewT=NULL;
        return;        //如果是空树，递归结束
    }
    else
    {
        NewT=new BiTNode;
        NewT->data=T->data;          //复制根结点
        Copy_BiTree(T->lchild,NewT->lchild);   //递归复制左子树
        Copy_BiTree(T->rchild,NewT->rchild);    //递归复制右子树
    }
}
```

## <3> 计算二叉树的深度

二叉树的深度为树中结点的最大层次，二叉树的深度为左右子树深度的较大者加1

```c
int Depth_BiTree(BiTree T)
{
    //计算二叉树T的深度
    if(T==NULL)
    {
        return 0;         //如过是空树，深度为0，递归结束
    }
    else
    {
        int m=Depth(T->lchild);      //递归计算左子树的深度记为m
        int m=Depth(T->rchild);      //递归计算右子树的深度记为n
        if(m>n)
            return m+1;       //二叉树的深度为m与n的较大者加1
        else
            return n+1;
    }
}
```

## <4> 统计二叉树中结点的个数

如果是空树，则结点个数为0；否则，结点个数为左子树的结点个数加上右子树的结点个数再加1

```c
int NodeCount_BiTree(BiTree &T)
{
    if(T==NULL)
    {
        return 0;   //空树，结点个数为0，递归结束
    }
    else
    {
       return NodeCount_BiTree(T->lchild)+NodeCount_BiTree(T->rchild)+1;
    }
}
```

